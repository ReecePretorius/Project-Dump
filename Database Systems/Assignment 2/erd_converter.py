# from asyncio.windows_events import NULL
from erd import *
from table import *

# This function converts an ERD object into a Database object
# The Database object should correspond to a fully correct implementation
# of the ERD, including both data structure and constraints, such that the
# CREATE TABLE statements generated by the Database object will populate an
# empty MySQL database to exactly implement the conceptual design communicated
# by the ERD.

def create_entity_set_table(entity_set, fk):
    # create and return any tables from the list of entity sets.
    if(fk == []):
        es_table = Table(entity_set.name, \
                         set(entity_set.attributes), \
                         set(entity_set.primary_key), \
                         set())
    else:
        es_table = Table(entity_set.name, \
                         set(entity_set.attributes), \
                         set(entity_set.primary_key), \
                         set(fk))
    return es_table

def create_relationship_table(R, keys):
    # add all attributes from relationship and PK's from entity_sets to set of attributes for the table.
    attrs = []

    for k in keys[0]:
        attrs.append(k)
    for attr in R.attributes:
        attrs.append(attr)
    # create and return any tables from the list of relationships.
    rel_table = Table(R.name, \
                      set(attrs), \
                      set(keys[0]), \
                      set(keys[1]))
    
    return rel_table

def get_keys(R, entity_sets):
    p_keys = []
    f_keys = []

    # go through all @entity_sets and add their PKs to @p_keys.
    # the combination of all the attributes in @p_keys is the PK for the table for relationship @R.
    for entity_set in entity_sets:
        for i in range(len(entity_set.connections)):
            if(entity_set.connections[i][0] == R.name):
                p_keys += entity_set.primary_key
            else:
                continue

    # go through all entity sets and if it has connection MANY to the Relationship @R add that @entity_sets PK's to a list @f_keys.
    # All PK's in the final list are FK's in the table for R.
    for entity_set in entity_sets:
        for i in range(len(entity_set.connections)):
            if(entity_set.connections[i][0] == R.name):
                # FORMAT: (('attr',), 'name', ('attr',))
                attr_tuple = tuple(entity_set.primary_key)
                f_keys.append((attr_tuple, entity_set.name, attr_tuple))
            else:
                continue
        

    return [p_keys, f_keys]

def check_if_one_to_many(relationships, entity_sets):
    # a list of connected entity sets for a passed in relationship.
    connections = []
    flag = 0

    for r in relationships:
        for e in entity_sets:
            for c in e.connections:
                if(r.name == c[0] and c[1] == Multiplicity.ONE):
                    flag = 1
                else:
                    continue

    return flag

def get_connections(relationships, entity_sets):
    # a list of connected entity sets for a passed in relationship.
    connections = []

    for r in relationships:
        temp_dict = {"type": 0, "R": [], "sets": []}
        temp_list = []
        temp_dict["R"] = r
        for e in entity_sets:
            if(e.parents != []):
                for p in entity_sets:
                    if(p.name == e.parents[0]):
                        temp_list.append(e)
                        temp_dict["type"] = 2
            for c in e.connections:
                if(r.name == c[0]):
                    temp_list.append(e)
                if(r.name == c[0] and c[1] == Multiplicity.ONE and temp_dict["type"] != 2):
                    temp_dict["type"] = 1
                else:
                    continue

        temp_dict["sets"] = temp_list 
        connections.append(temp_dict)

    return connections

# @TODO: Implement me!
def convert_to_table(erd):

    db = Database([])
    
    entity_sets = erd.entity_sets
    relationships = erd.relationships
    
    if(len(relationships) == 0):
        # no relationships.
        for entity_set in entity_sets:
            es = []
            child_fk = []
            if(entity_set.parents != []):
                for e in entity_sets:
                    if e.name == entity_set.parents[0]:
                        child_fk.append((tuple(e.primary_key), e.name, tuple(e.primary_key)))
                        es = EntitySet(entity_set.name, e.primary_key, e.primary_key, [], [], [])
                db.tables.append(create_entity_set_table(es, child_fk))
            else:
                db.tables.append(create_entity_set_table(entity_set, []))
    else:
        connections = get_connections(relationships, entity_sets)

        # FORMAT: [{1, relationship, entity_sets}, {0, relationship, entity_sets}]
        for item in connections:
            # parent/child relationship.
            if(item["type"] == 2):
                child_fk = []
                es = []
                for entity_set in item["sets"]:
                    if(entity_set.parents != []):
                        for e in item["sets"]:
                            if e.name == entity_set.parents[0]:
                                child_fk.append((tuple(e.primary_key), e.name, tuple(e.primary_key)))
                                es = EntitySet(entity_set.name, e.primary_key, e.primary_key, [], [], [])
                        db.tables.append(create_entity_set_table(es, child_fk))
                    else:
                        db.tables.append(create_entity_set_table(entity_set, []))
            
            # one-many // many-one relationship.
            elif(item["type"] == 1):
                # case 1: relationship has no PK.
                if(item["R"].primary_key == []):
                    many_side_attrs = []
                    fk = []
                    for entity_set in item["sets"]:
                        for c in entity_set.connections:
                            if(c[0] == item["R"].name and c[1] == Multiplicity.MANY):
                                many_side_attrs.append(entity_set.attributes)
                                many_side_attrs.append(item["R"].attributes)

                                for re_check in item["sets"]:
                                    if(re_check.connections[0][0] == item["R"].name and re_check.connections[0][1] == Multiplicity.ONE):
                                        many_side_attrs.append(re_check.primary_key)
                                        fk.append((tuple(re_check.primary_key), re_check.name, tuple(re_check.primary_key)))
                            
                                # flatten list of lists.
                                f_list = [item for sublist in many_side_attrs for item in sublist]
                            
                                db.tables.append(create_entity_set_table(EntitySet(entity_set.name, f_list, entity_set.primary_key, [], [], []), fk))

                            elif(c[0] == item["R"].name and c[1] == Multiplicity.ONE):
                                db.tables.append(create_entity_set_table(entity_set, []))
                            else:
                                continue
                
                # case 2: relationship has PK.
                else:
                    fk = get_keys(item["R"], item["sets"])[1]
                    temp_R = item["R"]

                    for entity_set in item["sets"]:
                        for c in entity_set.connections:
                            if(c[1] == Multiplicity.MANY):
                                temp_R.primary_key.append(entity_set.primary_key[0])
                            temp_R.attributes.append(entity_set.primary_key[0])
                        db.tables.append(create_entity_set_table(entity_set, []))
                    
                    temp_set = EntitySet(temp_R.name, temp_R.attributes, temp_R.primary_key, [], [], [])
                    
                    db.tables.append(create_entity_set_table(temp_set, fk))
            
            # many-many relationship.
            else:
                for entity_set in item["sets"]:
                    db.tables.append(create_entity_set_table(entity_set, []))

                keys = get_keys(item["R"], item["sets"])

                if(item["R"].primary_key != []):
                    for key in item["R"].primary_key:
                        keys[0].append(key)

                db.tables.append(create_relationship_table(item["R"], keys))
    
    return db


