#CSC 370 A02
#Assignment #1

import sys

class Relation:
    def __init__(self, attributes, FDeps):
        self.attributes = attributes
        self.FDeps = FDeps

class FD:
    def __init__(self, left, right):
        self.left = set(left)
        self.right = set(right)
        self.total = set(left + right)

    def closure(self, fd):
        if (fd.left.issubset(self.total) and not fd.right.issubset(self.total)):
            self.total = self.total.union(fd.right)
            return True

def main():
    if(len(sys.argv) <= 1):
        print("no argument given, please try again")
        sys.exit()
    if(len(sys.argv) > 5):
        print("Too many arguments")

    flag = sys.argv[3]
    
    # getting input attributes and fds and creating a Relation Object...
    fds = sys.argv[2].split(';')
    result = []
    for i in fds:
        arrow = i.split('/')
        left = arrow[0].split(',')
        right = arrow[1].split(',')
        result.append(FD(list(left), list(right)))
    fds = result

    attributes = set(sys.argv[1].split(','))

    R = [Relation(attributes, fds)]

    if(flag == 'B' or flag == 'b'):
        decomp = runBCNF(R)
        if(decomp == True):
            print("True")
        else:
            checkResult(decomp, sys.argv[4])

    elif(flag == '3' or flag == "3" or flag == 3):
        decomp = run3NF(R)
        if(decomp == True):
            print("True")
        else:
            checkResult(decomp, sys.argv[4])

###################################### BCNF and 3NF FUNCTIONS ######################################

def runBCNF(R):
    # print("running BCNF")

    # R is in BCNF already
    if(checkIfBCNF(R[0]) == 0):
        # print("already in BCNF")
        return(True)
    else:
        # print("Decomposing")
        decomposed = False
        while(decomposed == False):
            decomposed = True
            for r in R:
                # Select BCNF violation FD from set of dependencies X->Y (X is not a superkey)
                violation = checkIfBCNF(r)
                if(violation != 0):
                   decomposed = False
                   result = [] # store relations generated by the decomposition.

                   # r1 = closure of r+
                   r1 = violation.total
                   # r2 = (r \ r1) U r.left
                   r2 = r.attributes.difference(r1).union(violation.left)
                   
                   # project f to get FD's for r1 and r2, denoted f1 and f2
                   f1 = project(r, r1)
                   result.append(Relation(r1,f1))
                   
                   # project F to get FD's for R1 and R2, denoted F1 and F2
                   f2 = project(r, r2)
                   result.append(Relation(r2, f2))

                   R += result
                   R.remove(r)
                   break

        # print ("BCNF Decomposition Result:")
        finalResult = ""
        for i in R:
            finalResult += ",".join(sorted(list(i.attributes)))
            finalResult += ";"
        # print(finalResult[:-1])

        return(finalResult[:-1])

def run3NF(R):
    # print("running 3NF")

    if(checkIf3NF(R[0]) == 0):
        # print("already in 3NF")
        return(True)
    else:
        result = []
        # TODO: compute canonical set of FD's
        # Assume for now they are all already in canonical form

        for r in R:
            r = mergeFDs(r)

            # create relation(s) for each FD and add to result
            for FD in r.FDeps:
                result.append((set.union(FD.left, FD.right)))
        
            # check if any relations contain a key for R, if none then add relation with attributes of minimal key of R
            if(not checkKeys(result, r.attributes, r.FDeps)):
                # add relation containing attrs for minimal key of R
                minimal = set()
                temp = set()
                attributes = r.attributes
                for attribute in sorted(attributes):
                    for FD in r.FDeps:
                        if(set(attribute).issubset(FD.right)):
                            # print("attribute: " + attribute + " found")
                            temp.add(attribute)

                minimal = attributes.difference(temp)
                result.append(minimal)

        # drop redundent relations
        for i in range(len(result)):
            for j in range(i + 1, len(result)):
                if(result[i].issubset(result[j])):
                    # print("subset found")
                    result.remove(result[i])

        finalResult = ""
        for i in result:
            finalResult += ",".join(sorted(list(i)))
            finalResult += ";"
        # print(finalResult[:-1])

        return(finalResult[:-1])

######################################### HELPER FUNCTIONS #########################################

# Checks if 'relation' is already in BCNF, if not it returns the BCNF violation FD.
def checkIfBCNF(relation):
    for FD1 in relation.FDeps:
        for FD2 in relation.FDeps:
            if (FD1.closure(FD2)):
                FD2 = FD1
        if (not FD1.total.issuperset(relation.attributes)):
            return FD1
    return 0

# TODO: Checks if 'relation' is already in 3NF.
def checkIf3NF(relation):
    return 1

# project onto relation to generate fds.
def project(relation, attributes):
        result = []
        for FD in relation.FDeps:
            if (FD.left.issubset(attributes) and FD.right.issubset(attributes)):
                result.append(FD)
        return result

# merge FD's with the same LHS.
def mergeFDs(relation):
    for FD1 in relation.FDeps:
        for FD2 in relation.FDeps:
            if(not FD1.total == FD2.total):
                if(FD1.left == FD2.left):
                    FD1.right.add(list(FD2.right)[0])
                    relation.FDeps.remove(FD2)
                    # print(type(FD1.left))
                    # print(str(FD2.left) + "->" + str(FD2.right))
    return(relation)

# Check if the relations from the resulting decomposition matches the set of input decomposition relations.
def checkResult(result, input):
    # print("checking decomposition against input")

    result = [x.split(',') for x in result.split(';')]
    input = [x.split(',') for x in input.split(';')]

    resultSet = set(frozenset(i) for i in result)
    inputSet = set(frozenset(i) for i in input)

    if(resultSet == inputSet):
        print("True")
    else:
        print("False")

# check if any relations contain a key for R.
def checkKeys(relations, attributes, FDs):
    left = []
    right = []
    bool = False

    for FD in FDs:
        left.append(list(FD.left))
        right.append(list(FD.right))

    for r in relations:
        # attributes of relations in a list
        for i in range(len(FDs)):
            if (set(left[i]) <= r):
                r = r | set(right[i])
            for i in range(len(FDs)):
                if (set(left[i]) <= r):
                    r = r | set(right[i])

        if(r == attributes):
            bool = True
    
    return(bool)

####################################################################################################

if __name__ == "__main__":
    main()

